### Selector

> 논블록킹의 설계를 보면 이전 블로킹의 단점들을 해결할 수 있다.
>
> 

![Netty 핵심 컴포넌트](https://happygrammer.github.io/java/netty/selector.png)

##### **java.nio.channels.selector** 클래스가 논블로킹 입출력 구현의 핵심 역할을 한다.

언제든지 읽기나 쓰기 작업의 완료 상태를 확인할 수 있어 한 스레드로 여러 동시 연결을 처리할 수 있다.

- 적은 수의 쓰레드로 많은 연결을 처리할 수 있으므로 컨텍스트 전환에 따른 오버헤드 감소
- 입출력을 처리하지 않을 때는 스레드를 다른 작업에 활용할 수 있다.



#### Channel

> 하나 이상의 입출력 작업을 수행할 수 있는 하드웨어 장치, 파일, 네트워크 소켓, 프로그램 컴포넌트와 같은 엔티티에 대한 열린 연결



#### Callback

> 다른 메서드로 자신에 대한 참조를 제공할 수 있는 메서드



#### Future

> 작업이 완료되면 애플리케이션에 알리는 한 방법



> ### 네티의 비동기 프로그래밍 모델은 **<u>Future</u>**, **<u>콜백</u>**의 개념, 그리고 **<u>이벤트를 핸들러 메서드로 발송하는 작업</u>**을 기반으로 작동한다.



#### ChannelPipeline

> ChannelHandler 체인을 위한 컨테이너를 제공하며, 체인 상에서 인바운드와 아웃바운드 이벤트를 전파하는 API를 정의한다.
>
> channel이 생성되면 여기에 자동으로 자체적인 ChannelPipeline이 할당된다.
>
> - ChannelInitializer 구현은 ServerBootstrap에 등록된다.
> - ChannelInitializer.initChannel()이 호출되면 ChannelInitializer의 커스텀 집합을 파이프라인에 설치한다.
> - ChannelInitializer는 ChannelPipeline에서 자신을 제거한다.
>
> 



ChannelHandler를 ChannelPipeline에 추가할 때 ChannelHandler 및 ChannelPipeline 간의 바인딩을 나타내는

**ChannelHandlerContext** 하나가 할당된다. 이 객체는 기본 Channel을 가져오는 데 이용할 수 있지만 실제로는 아웃바운드 데이터를 기록할 때 주로 사용한다.



- 메시지를 보낼 때
  - Channel에 직접 기록하면, ChannelPipeline의 뒤쪽에서 시작되며,
  - ChannelHandlerContext에 기록하면, ChannelPipeline의 다음 Handler에서 시작된다.





##### 인바운드 데이터의 경우 Channel에서 읽는 각 메시지에 대해 호출되는 channelRead 를 재정의한다.

##### 이 메서드는 디코더의 decode() 메서드를 호출한 후 디코딩된 바이트를 파이프라인의 다음 ChannelInboundHandler로 전달한다.

##### 아웃바운드 메시지를 위한 패턴은 반대이며 인코더가 메시지를 바이트로 변환한 후 다음 ChannelOutboundHandler로 전달한다.











